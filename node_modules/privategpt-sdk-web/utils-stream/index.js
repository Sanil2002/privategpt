export class StreamingTextResponse extends Response {
    constructor(res, init) {
        let processedStream = res;
        super(processedStream, {
            ...init,
            status: 200,
            headers: {
                'Content-Type': 'text/plain; charset=utf-8',
                ...init?.headers,
            },
        });
    }
}
async function* streamable(stream) {
    for await (let chunk of stream) {
        yield chunk;
    }
}
function createTransformer() {
    const textEncoder = new TextEncoder();
    return new TransformStream({
        async transform(message, controller) {
            controller.enqueue(textEncoder.encode(JSON.stringify(message)));
        },
    });
}
function readableFromAsyncIterable(iterable) {
    let it = iterable[Symbol.asyncIterator]();
    try {
        return new ReadableStream({
            async pull(controller) {
                const { done, value } = await it.next();
                if (done)
                    controller.close();
                else
                    controller.enqueue(value);
            },
            async cancel(reason) {
                await it.return?.(reason);
            },
        });
    }
    catch (error) {
        console.error(error);
    }
    return new ReadableStream({});
}
export const streamToReadableStream = (stream) => {
    return readableFromAsyncIterable(streamable(stream)).pipeThrough(createTransformer());
};
