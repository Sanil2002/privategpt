import { useRef, useState } from 'react';
import { getAssistantResponse } from './utils';
import useSWR from 'swr';
export const usePrompt = ({ prompt, includeSources = false, useContext = false, onFinish, client, systemPrompt, enabled = true, contextFilter, }) => {
    const [completion, setCompletion] = useState('');
    const abortController = useRef(null);
    const queryKey = ['prompt', prompt];
    const shouldFetch = enabled && prompt?.trim() !== '';
    const fetcher = async () => {
        abortController.current = new AbortController();
        if (!prompt)
            return '';
        let sources = [];
        setCompletion('');
        const result = await getAssistantResponse({
            fn: client.contextualCompletions.promptCompletionStream.bind(client.contextualCompletions),
            args: [
                {
                    prompt,
                    includeSources,
                    useContext,
                    systemPrompt,
                    contextFilter,
                },
                {},
                abortController.current.signal,
            ],
            onNewMessage: (openAiCompletion) => {
                const message = openAiCompletion.choices?.[0]?.delta?.content || '';
                const chunks = openAiCompletion.choices?.[0]?.sources?.reduce((acc, chunk) => {
                    const chunkInAcc = acc.find((c) => c.document?.docMetadata?.file_name ===
                        chunk.document?.docMetadata?.file_name);
                    if (chunk && !chunkInAcc) {
                        acc.push(chunk);
                    }
                    return acc;
                }, []) ?? [];
                if (chunks.length > 0 && sources.length === 0) {
                    sources = chunks;
                }
                setCompletion((prev) => prev + message);
            },
            abortController: abortController.current,
        });
        onFinish?.({
            completion: result,
            sources,
        });
        return result;
    };
    const { isLoading } = useSWR(queryKey, shouldFetch ? fetcher : null, {
        revalidateOnFocus: false,
        revalidateOnReconnect: false,
    });
    return {
        completion,
        isLoading,
        setCompletion,
        stop: () => {
            abortController.current?.abort();
            abortController.current = null;
            onFinish?.({
                completion: completion || '',
                sources: [],
            });
            setCompletion('');
        },
    };
};
